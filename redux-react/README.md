# Redux

## Redux란?

- 리덕스는 리액트 생태계에서 가장 사용률이 높은 상태관리 라이브러리이다. 리덕스를 사용하면 컴포넌트들의 상태 관련 로직들을 다른 파일들로 분리시켜서 더욱 효율적으로 관리 할 수 있으며 글로벌 상태 관리도 손쉽게 할 수 있다.
- Context API를 사용해도 글로벌 상태 관리를 할 수 있고 관리 로직을 분리 할 수 있다. 특히, Context API와 useReducer HOOK을 사용해서 개발하는 흐름은 리덕스를 사용하는 것과 매우 개발 방식이 유사하다.

## 미들웨어

- 리덕스에는 미들웨어 라는 개념이 존재한다. 리덕스로 상태 관리를 할 때에는 useReducer를 사용해볼때 접했던 개념인 리듀서 함수를 사용한다. 리덕스의 미들웨어를 사용하면 액션 객체가 리듀서에서 처리되기 전에 우릭 원하는 작업들을 수행할 수 있다.
    + 특정 조건에 따라 액션이 무시되게 만들 수 있다.
    + 액션을 콘솔에 출력하거나, 서버쪽에 로깅할 수 있다.
    + 액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달되도록 할 수 있다.
    + 특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생되도록 할 수 있다.
    + 특정 액션이 발생했을 떼 자바스크립트 합수를 실행시킬 수 있다.
- 미들웨어는 주로 비동기 작업을 처리 할 때 많이 사용된다.
- useReducer Hook에서도 외부 라이브러리를 사용하면 미들웨어를 사용 할 수도 있습니다. 다만, 자주 사용되는 방식은 아니다.

## 유용한 함수와, Hooks

- Context API와 useReducer를 사용 할 때에는 Context도 새로 만들고, Context의 Provider 설정도 하고 각 Context를 편하게 사용하기 위해 전용 커스텀 Hook을 따로 만들어서 사용하기도 했다. 리덕스에서는 이와 비슷한 작업을 편리하게 해줄 수 있는 여러 기능들이 존재한다. 
- connect 함수를 사용하면 리덕스의 상태 또는 액션 생성 함수를 컴포넌트의 props로 받아올 수 있으며, useSelector, useDispatch, useStore과 같은 Hooks를 사용하면 돈쉽게 상태를 조회하거나 액션을 디스패치 할 수도 있다.
- connect 함수와 useSelector 함수에는 내부적으로 최적화가 잘 이루어져있어서 실제 상태가 바뀔때만 컴포넌트가 리렌더링 됩니다. 반면에 Context API를 사용할 때에는 그러한 최적화가 자동으로 이루어져있지 않기 때문에 Context가 지니고 있는 상태가 바뀌면 해당 Context의 Provider내부 컴포넌트들이 모두 리렌더링 된다.

## 하나의 커다란 상태

- Context API를 사용해서 글로벌 상태를 관리 할 때에는 일반적으로 기능별로 Context를 만들어서 사용하는 것이 일반적이다. 반면 리덕스에서는 모든 글로벌 상태를 하나의 커다란 상태 객체에 넣어서 사용하는 것이 필수적이다. 떄문에 매번 Context를 새로 만들지 않아도 된다.

## 리덕스는 언제 써야하나?

1. 프로젝트 규모가 큰가?
    +   YES: Redux
    +   No: Context API
2. 비동기 작업울 자주 하게 되는가?
    +   YES: Redux
    +   No: Context API
3. 리덕스를 배워보니 사용하기 편한가?
    +   YES: Redux
    +   No: Context API

## 리덕스에서 사용하는 키워드

### Action

- 상태에 어떠한 변화가 필요하게될 때는 액션이라는 것을 발생시킨다. 이는 하나의 객체로 표현이 된다.
</br>

```
{
    type: "TOGGLE_VALUE"
}

```
</br>
- 액션 객체는 type필드를 필수적으로 가지고 있어야하고 그 외의 값들은 개발자 마음대로 넣어줄 수 있다.
</br>

```

{
    type: "ADD_TODO"
    date: {
        id: 0,
        text: "리덕스"
    }
}

```
</br>

### 액션 생성 함수

- 액션 생성함수는, 액션을 만드는 함수이다. 단순히 파라미터를 받아와서 액션 객체 형태롤 만들어준다.

```

export function addTodo(data) {
    return {
        type: "ADD_TODO",
        data
    };
}

export const changeInput = text => ({
    type: "CHANGE_INPUT",
    text
});

```

</br>

### 스토어 

리덕스에서는 한 애플리케이션당 하나의 스토어를 만들게 된다. 스토어 안에는, 핸재의 앱 상태와, 리듀서가 들어가 있고, 몇기지 내장 함수들이 있다.

### 디스패치

- 디스패치는 스토어의 내장함수 중 하나이다. 디스패치는 액션을 발생시키는 것 이라고 이해하면 된다. dispatch라는 함수에는 액션을 파라미터로 전달한다. dispatch(action)과 같은 형태이다. 그렇게 호출을 하면, 스토어는 리듀서 함수를 실행시켜서 해당 액션을 처리하는 로직이 있다면 액션을 참고하여 새로운 상태를 만든다.

### 구독

- 구독 또한 스토어의 내장함수 중 하나이다. subscribe 함수는, 함수 형태의 값을 파라미터로 받아온다. subscribe 함수에 특정 함수를 전달하면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출된다. 리액트에서 리덕스를 사용하게 될 대 보통 이 함수를 직점 사용할 일이 없다. 

## 리덕스의 3규칙

### 하나의 애플리케이션 안에는 하나의 스토어가 있다.

- 하나의 애플리케이션에선 단 한개의 스토어를 만들어서 사용한다. 여러개의 스토어를 사용하는 것은 사실 가능하기는 하나, 권장 되지는 않는다. 특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있다. 하지만 그렇게 하면, 개발 도구를 활용하지 못하게 된다.

### 상태는 읽기 전용이다.

- 리액트에서 state를 업데이트 해야 할 때, setState를 사용하고, 배열을 업데이트 해야 할 때는 배열 자체에 puch를 직접 하지 않고, concat같은 함수를 사용하여 기존의 배열은 수정하지 않고 새로운 배열을 만들어서 교체하는 방식으로 업데이트를 한다. 리덕스도 마찬가지이다. 기존의 상태를 건들이지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면, 나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있다.
- 리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위해서 shallow equality검사를 하기 때문이다. 이를 통하여 객체의 변화를 감지 할 때 객체의 깊숙한 안쪽까지 비교를 하는 것이 아니라 겉핥기 식으로 비교를 해서 성능을 유지한다.

### 변화를 일으키는 함수, 리듀서는 순수한 함수여야 한다.

- 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받는다.
- 이전의 상태는 절대로 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다.
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 한다.